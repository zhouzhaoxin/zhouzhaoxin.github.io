
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "Mediumish Template for Jekyll",
    "body": "This website is built with Jekyll and Mediumish template for Jekyll. It's for demonstration purposes, no real content can be found. Mediumish template for Jekyll is compatible with Github pages, in fact even this demo is created with Github Pages and hosted with Github.  Documentation: Please, read the docs here. Questions or bug reports?: Head over to our Github repository! Buy me a coffeeThank you for your support! Your donation helps me to maintain and improve Mediumish . Buy me a coffee Documentation"
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      推荐:                                                                                                                                                                                                                                                                                                                                                                                   存储过程高级篇                              :               继续上文的初级篇，聊一聊存储过程的常用特性，谈谈存储过程在工作中的具体使用，希望能对读者有所帮助。 参数传入模式 PL/SQL存储过程有三种传参模式in 、out、in out。默认情况下（即不写）为in模式 先来看看下面的存储过程： 1 2 3 4 5 6 7 8 9 10 --in 、out、 in out模式测试 create or replace procedure proc_param_demo(p1. . . :                                                                                                                                                                       zhouzhaoxin                                29 Dec 2016                                                                                                                                                                                                                                                                                                                  存储过程初级篇                              :               本文旨在把自己学到的有关存储过程的知识和大家分享，并希望能够帮助正在被存储过程折磨的同学。什么是存储过程 官方定义：A procedure is a subprogram that performs a specific action:                                                                                                                                                                       zhouzhaoxin                                24 Dec 2016                                                                                                                                              所有博客:                                                                                                     数据结构与算法-二叉树              :       二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）:                                                                               zhouzhaoxin                26 Mar 2019                                                                                                                                     数据结构与算法-树与树算法              :       树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：:                                                                               zhouzhaoxin                16 Mar 2019                                                                                                                                     Soket理解              :       在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。:                                                                               zhouzhaoxin                20 Sep 2018                                                                                                                                     数据结构与算法-队列              :       队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。:                                                                               zhouzhaoxin                16 Aug 2018                                                                                                                                     数据结构与算法-栈              :       栈（stack），有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素，它的特点在于只能允许在容器的一端（称为栈顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。:                                                                               zhouzhaoxin                16 Jun 2018                                                                                                                                     数据结构与算法-排序算法比较与搜索              :       搜索搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找:                                                                               zhouzhaoxin                10 Jun 2018                                               &laquo; Prev       1        2        3        4        5        6      Next &raquo; "
    }, {
    "id": 4,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       推荐:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       所有博客:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       推荐:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       所有博客:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       推荐:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       所有博客:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       推荐:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       所有博客:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       推荐:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       所有博客:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/",
    "title": "数据结构与算法-二叉树",
    "body": "2019/03/26 - 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree） 二叉树的性质(特性): 性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i&gt;0）性质2: 深度为k的二叉树至多有2^k - 1个结点（k&gt;0）性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外） 完全二叉树: 若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。 满二叉树: 除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。 二叉树的节点表示以及树的创建: 通过使用Node类中定义三个属性，分别为elem本身的值，还有lchild左孩子和rchild右孩子 123456class Node(object):     节点类     def __init__(self, elem=-1, lchild=None, rchild=None):    self. elem = elem    self. lchild = lchild    self. rchild = rchild树的创建,创建一个树的类，并给一个root根节点，一开始为空，随后添加节点 123456789101112131415161718192021222324252627class Tree(object):     树类     def __init__(self, root=None):    self. root = root  def add(self, elem):       为树添加节点       node = Node(elem)    #如果树是空的，则对根节点赋值    if self. root == None:      self. root = node    else:      queue = []      queue. append(self. root)      #对已有的节点进行层次遍历      while queue:        #弹出队列的第一个元素        cur = queue. pop(0)        if cur. lchild == None:          cur. lchild = node          return        elif cur. rchild == None:          cur. rchild = node          return        else:          #如果左右子树都不为空，加入队列继续判断          queue. append(cur. lchild)          queue. append(cur. rchild)二叉树的遍历: 树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。 深度优先遍历: 对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。我们来给出它们的详细定义，然后举例看看它们的应用。 先序遍历 在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树根节点-&gt;左子树-&gt;右子树 1234567def preorder(self, root):      递归实现先序遍历      if root == None:     return   print root. elem   self. preorder(root. lchild)   self. preorder(root. rchild)中序遍历 在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树左子树-&gt;根节点-&gt;右子树 1234567def inorder(self, root):      递归实现中序遍历      if root == None:     return   self. inorder(root. lchild)   print root. elem   self. inorder(root. rchild)后序遍历 在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点左子树-&gt;右子树-&gt;根节点 1234567def postorder(self, root):      递归实现后续遍历      if root == None:     return   self. postorder(root. lchild)   self. postorder(root. rchild)   print root. elem 广度优先遍历(层次遍历): 从树的root开始，从上到下从从左到右遍历整个树的节点 1234567891011121314def breadth_travel(self, root):       利用队列实现树的层次遍历       if root == None:      return    queue = []    queue. append(root)    while queue:      node = queue. pop(0)      print node. elem,      if node. lchild != None:        queue. append(node. lchild)      if node. rchild != None:        queue. append(node. rchild)"
    }, {
    "id": 11,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%8E%E6%A0%91%E7%AE%97%E6%B3%95/",
    "title": "数据结构与算法-树与树算法",
    "body": "2019/03/16 - 树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：  每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树；比如说： 树的术语:  节点的度：一个节点含有的子树的个数称为该节点的度； 树的度：一棵树中，最大的节点的度称为树的度； 叶节点或终端节点：度为零的节点； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点：具有相同父节点的节点互称为兄弟节点； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推； 树的高度或深度：树中节点的最大层次； 堂兄弟节点：父节点在同一层的节点互为堂兄弟； 节点的祖先：从根到该节点所经分支上的所有节点； 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林；  树的种类:   无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；     二叉树：每个节点最多含有两个子树的树称为二叉树；   完全二叉树：对于一颗二叉树，假设其深度为d(d&gt;1)。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树，其中满二叉树的定义是所有叶节点都在最底层的完全二叉树;   平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；   排序二叉树（二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树）；   霍夫曼树（用于信息编码）：带权路径最短的二叉树称为哈夫曼树或最优二叉树；   B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。   树的存储与表示: 顺序存储：将数据结构存储在固定的数组中，然在遍历速度上有一定的优势，但因所占空间比较大，是非主流二叉树。二叉树通常以链式存储。 链式存储： 由于对节点的个数无法掌握，常见树的存储表示都转换成二叉树进行处理，子节点个数最多为2 常见的一些树的应用场景  xml，html等，那么编写这些东西的解析器的时候，不可避免用到树 路由协议就是使用了树的算法 mysql数据库索引 文件系统的目录结构 所以很多经典的AI算法其实都是树搜索，此外机器学习中的decision tree也是树结构"
    }, {
    "id": 12,
    "url": "http://localhost:4000/Soket%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/",
    "title": "Soket理解",
    "body": "2018/09/20 - 在计算机科学中，网络套接字（英语：Network socket），又译网络套接字、网络接口、网络插槽，是电脑网络中进程间数据流的端点。使用以网际协议（Internet Protocol）为通信基础的网络套接字，称为网际套接字（Internet socket）。因为网际协议的流行，现代绝大多数的网络套接字，都是属于网际套接字。 socket是一种操作系统提供的进程间通信机制。 基本概念: 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4. 2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。 在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连接后，再加上使用的协议（protocol），这个五元组（five-element tuple)，作为套接字对（socket pairs），之后就可以彼此交换数据。 例如，再同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。 操作系统根据套接字地址，可以决定应该将数据送达特定的进程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。 Python 实现: 每一种语言都会对socket进行封装，从而控制进程间的通讯。web服务器就是对socket实现的封装。 客户端: 当你点击链接到此页面的时候，你的浏览器做了如下动作 1234567# coding:utf-8# socket. AF_INET  用于服务器与服务器之间的网络通信# socket. SOCK_STREAM  基于TCP的流式socket通信import sockets = socket. socket(socket. AF_INET, socket. SOCK_STREAM)s. connect(( www. python. org , 80))s. send(b'1234') # 返回字符串的长度4先建立一个服务器与服务器间通讯的socket（其协议为TCP，三次握手）,然后使用socket建立到本网站的链接。链接建立之后，我们创建的名为s的socket就可以发送一个包含信息的请求,之后,客户端会建立一个相同的socket接受返回的信息，然后销毁。客户端的socket一般只用于一次交换。 服务端: 1234567# coding:utf-8import socketserversocket = socket. socket(socket. AF_INET, socket. SOCK_STREAM)# 绑定端口serversocket. bind((socket. gethostname(), 80))# 监听端口，变成一个服务器serversocket. listen(5)使用socket. gethostname()作为url可以接受所有请求，而如果使用localhost 或者127. 0. 0. 1我们就只能使用当前的机器访问。 listen方法的参数可以制定此socket的最大连接数，超过最大链接则拒绝外部请求 有了一个服务端的socket之后我们就可以把他放到循环中处理请求 123456while True:  (clientsocket,address) = serversocket. accept()  # clientsocket为和client建立的链接  # 假设我们通过一个线程处理链接  ct = client_thread(clientsocket)  ct. run()服务器端的socket只做了这些，它不会发送任何数据，也不会接受任何数据，他只是产生了一个客户端的socket每一个被创建的客户端socket都会通过connect()方法与其他的socket进行通讯 总结: 理解socket的基本概念，了解在socket的程序实现。socket有两种，服务器端和客户端，服务器端socket只是通过请求产生客户端socket，客户端socket可以通过建立的connection()进行通讯。 客户端的socket和服务器端通过客户端请求产生的socket是同等的。 "
    }, {
    "id": 13,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/",
    "title": "数据结构与算法-队列",
    "body": "2018/08/16 - 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。 队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。 队列的实现: 同栈一样，队列也可以用顺序表或者链表实现。 操作:  Queue() 创建一个空的队列 enqueue(item) 往队列中添加一个item元素 dequeue() 从队列头部删除一个元素 is_empty() 判断一个队列是否为空 size() 返回队列的大小123456789101112131415161718192021222324class Queue(object):     队列     def __init__(self):    self. items = []  def is_empty(self):    return self. items == []  def enqueue(self, item):       进队列       self. items. insert(0,item)  def dequeue(self):       出队列       return self. items. pop()  def size(self):       返回大小       return len(self. items)if __name__ ==  __main__ :  q = Queue()  q. enqueue( hello )  q. enqueue( world )  q. enqueue( itcast )  print q. size()  print q. dequeue()  print q. dequeue()  print q. dequeue()"
    }, {
    "id": 14,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%88/",
    "title": "数据结构与算法-栈",
    "body": "2018/06/16 - 栈（stack），有些地方称为堆栈，是一种容器，可存入数据元素、访问元素、删除元素，它的特点在于只能允许在容器的一端（称为栈顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。没有了位置概念，保证任何时候可以访问、删除的元素都是此前最后存入的那个元素，确定了一种默认的访问顺序。 由于栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 栈结构实现: 栈可以用顺序表实现，也可以用链表实现。 栈的操作:  Stack() 创建一个新的空栈 push(item) 添加一个新的元素item到栈顶 pop() 弹出栈顶元素 peek() 返回栈顶元素 is_empty() 判断栈是否为空 size() 返回栈的元素个数  1234567891011121314151617181920212223242526272829class Stack(object):    栈    def __init__(self):    self. items = [] def is_empty(self):      判断是否为空      return self. items == [] def push(self, item):      加入元素      self. items. append(item) def pop(self):      弹出元素      return self. items. pop() def peek(self):      返回栈顶元素      return self. items[len(self. items)-1] def size(self):      返回栈的大小      return len(self. items)if __name__ ==  __main__ : stack = Stack() stack. push( hello ) stack. push( world ) stack. push( itcast ) print stack. size() print stack. peek() print stack. pop() print stack. pop() print stack. pop()    执行过程如下：:  "
    }, {
    "id": 15,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E4%B8%8E%E6%90%9C%E7%B4%A2/",
    "title": "数据结构与算法-排序算法比较与搜索",
    "body": "2018/06/10 -  搜索: 搜索是在一个项目集合中找到一个特定项目的算法过程。搜索通常的答案是真的或假的，因为该项目是否存在。 搜索的几种常见方法：顺序查找、二分法查找、二叉树查找、哈希查找 二分法查找: 二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 二分法查找实现: 非递归实现 123456789101112131415def binary_search(alist, item):   first = 0   last = len(alist)-1   while first&lt;=last:     midpoint = (first + last)/2     if alist[midpoint] == item:       return True     elif item &lt; alist[midpoint]:       last = midpoint-1     else:       first = midpoint+1  return Falsetestlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]print(binary_search(testlist, 3))print(binary_search(testlist, 13))递归实现 123456789101112131415def binary_search(alist, item):  if len(alist) == 0:    return False  else:    midpoint = len(alist)//2    if alist[midpoint]==item:     return True    else:     if item&lt;alist[midpoint]:      return binary_search(alist[:midpoint],item)     else:      return binary_search(alist[midpoint+1:],item)testlist = [0, 1, 2, 8, 13, 17, 19, 32, 42,]print(binary_search(testlist, 3))print(binary_search(testlist, 13))时间复杂度:  最优时间复杂度：O(1) 最坏时间复杂度：O(logn)"
    }, {
    "id": 16,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-归并排序",
    "body": "2018/06/07 - 归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。 将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。 归并排序的分析 123456789101112131415161718192021222324252627def merge_sort(alist):  if len(alist) &lt;= 1:    return alist  # 二分分解  num = len(alist)/2  left = merge_sort(alist[:num])  right = merge_sort(alist[num:])  # 合并  return merge(left,right)def merge(left, right):  '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''  #left与right的下标指针  l, r = 0, 0  result = []  while l&lt;len(left) and r&lt;len(right):    if left[l] &lt; right[r]:      result. append(left[l])      l += 1    else:      result. append(right[r])      r += 1  result += left[l:]  result += right[r:]  return resultalist = [54,26,93,17,77,31,44,55,20]sorted_alist = mergeSort(alist)print(sorted_alist)时间复杂度:  最优时间复杂度：O(nlogn) 最坏时间复杂度：O(nlogn) 稳定性：稳定"
    }, {
    "id": 17,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-希尔排序",
    "body": "2018/05/01 - 希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 希尔排序过程: 希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样(竖着的元素是步长组成)： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]。这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294最后以1步长进行排序（此时就是简单的插入排序了） 希尔排序的分析: 1234567891011121314151617def shell_sort(alist):  n = len(alist)  # 初始步长  gap = n / 2  while gap &gt; 0:    # 按步长进行插入排序    for i in range(gap, n):      j = i      # 插入排序      while j&gt;=gap and alist[j-gap] &gt; alist[j]:        alist[j-gap], alist[j] = alist[j], alist[j-gap]        j -= gap    # 得到新的步长    gap = gap / 2alist = [54,26,93,17,77,31,44,55,20]shell_sort(alist)print(alist)时间复杂度:  最优时间复杂度：根据步长序列的不同而不同 最坏时间复杂度：O(n2) 稳定想：不稳定  希尔排序演示:    "
    }, {
    "id": 18,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-快速排序",
    "body": "2018/04/22 - 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤为：  从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。快速排序的分析: 1234567891011121314151617181920212223242526272829303132def quick_sort(alist, start, end):     快速排序     # 递归的退出条件  if start &gt;= end:    return  # 设定起始元素为要寻找位置的基准元素  mid = alist[start]  # low为序列左边的由左向右移动的游标  low = start  # high为序列右边的由右向左移动的游标  high = end  while low &lt; high:    # 如果low与high未重合，high指向的元素不比基准元素小，则high向左移动    while low &lt; high and alist[high] &gt;= mid:      high -= 1    # 将high指向的元素放到low的位置上    alist[low] = alist[high]    # 如果low与high未重合，low指向的元素比基准元素小，则low向右移动    while low &lt; high and alist[low] &lt; mid:      low += 1    # 将low指向的元素放到high的位置上    alist[high] = alist[low]  # 退出循环后，low与high重合，此时所指位置为基准元素的正确位置  # 将基准元素放到该位置  alist[low] = mid  # 对基准元素左边的子序列进行快速排序  quick_sort(alist, start, low-1)  # 对基准元素右边的子序列进行快速排序  quick_sort(alist, low+1, end)alist = [54,26,93,17,77,31,44,55,20]quick_sort(alist,0,len(alist)-1)print(alist)时间复杂度:  最优时间复杂度：O(nlogn) 最坏时间复杂度：O(n2) 稳定性：不稳定从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。 快速排序演示: "
    }, {
    "id": 19,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-插入排序",
    "body": "2018/04/16 - 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 插入排序分析: 12345678910def insert_sort(alist):  # 从第二个位置，即下标为1的元素开始向前插入  for i in range(1, len(alist)):    # 从第i个元素开始向前比较，如果小于前一个元素，交换位置    for j in range(i, 0, -1):      if alist[j] &lt; alist[j-1]:        alist[j], alist[j-1] = alist[j-1], alist[j]alist = [54,26,93,17,77,31,44,55,20]insert_sort(alist)print(alist)时间复杂度:  最优时间复杂度：O(n) （升序排列，序列已经处于升序状态） 最坏时间复杂度：O(n2) 稳定性：稳定  插入排序演示:  "
    }, {
    "id": 20,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-冒泡排序",
    "body": "2018/04/10 - 排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定顺序进行排列的一种算法。 排序算法的稳定性: 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。 (4, 1) (3, 1) (3, 7)（5, 6）在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有： (3, 1) (3, 7) (4, 1) (5, 6) （维持次序） (3, 7) (3, 1) (4, 1) (5, 6) （次序被改变）不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。作这件事情的一个方式是人工扩充键值的比较，如此在其他方面相同键值的两个对象间之比较，（比如上面的比较中加入第二个标准：第二个键值的大小）就会被决定使用在原先数据次序中的条目，当作一个同分决赛。然而，要记住这种次序通常牵涉到额外的空间负担。 冒泡排序: 冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 冒泡排序算法的运作如下：  比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。冒泡排序的分析: 交换过程图示(第一次)： 那么我们需要进行n-1次冒泡过程，每次对应的比较次数如下图所示： 123456789def bubble_sort(alist):  for j in range(len(alist)-1,0,-1):    # j表示每次遍历需要比较的次数，是逐渐减小的    for i in range(j):      if alist[i] &gt; alist[i+1]:        alist[i], alist[i+1] = alist[i+1], alist[i]li = [54,26,93,17,77,31,44,55,20]bubble_sort(li)print(li)时间复杂度  最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。） 最坏时间复杂度：O(n2) 稳定性：稳定  冒泡排序的演示:  "
    }, {
    "id": 21,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/",
    "title": "数据结构与算法-选择排序",
    "body": "2018/03/15 - 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。 选择排序分析: 排序过程：  红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 1234567891011121314151617def selection_sort(alist):  n = len(alist)  # 需要进行n-1次选择操作  for i in range(n-1):    # 记录最小位置    min_index = i    # 从i+1位置到末尾选择出最小数据    for j in range(i+1, n):      if alist[j] &lt; alist[min_index]:        min_index = j    # 如果选择出的数据不在正确位置，进行交换    if min_index != i:      alist[i], alist[min_index] = alist[min_index], alist[i]alist = [54,226,93,17,77,31,44,55,20]selection_sort(alist)print(alist)时间复杂度:  最优时间复杂度：O(n2) 最坏时间复杂度：O(n2) 稳定性：不稳定（考虑升序每次选择最大的情况）  选择排序演示:    "
    }, {
    "id": 22,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/",
    "title": "数据结构与算法-双端队列",
    "body": "2017/12/15 - 双端队列（deque，全名double-ended queue），是一种具有队列和栈的性质的数据结构。 双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。双端队列可以在队列任意一端入队和出队。 操作:  Deque() 创建一个空的双端队列 add_front(item) 从队头加入一个item元素 add_rear(item) 从队尾加入一个item元素 remove_front() 从队头删除一个item元素 remove_rear() 从队尾删除一个item元素 is_empty() 判断双端队列是否为空 size() 返回队列的大小  123456789101112131415161718192021222324252627282930313233class Deque(object):    双端队列    def __init__(self):   self. items = [] def is_empty(self):      判断队列是否为空      return self. items == [] def add_front(self, item):      在队头添加元素      self. items. insert(0,item) def add_rear(self, item):      在队尾添加元素      self. items. append(item) def remove_front(self):      从队头删除元素      return self. items. pop(0) def remove_rear(self):      从队尾删除元素      return self. items. pop() def size(self):      返回队列大小      return len(self. items)if __name__ ==  __main__ : deque = Deque() deque. add_front(1) deque. add_front(2) deque. add_rear(3) deque. add_rear(4) print deque. size() print deque. remove_front() print deque. remove_front() print deque. remove_rear() print deque. remove_rear()   "
    }, {
    "id": 23,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/",
    "title": "数据结构与算法-单向循环链表",
    "body": "2017/12/06 - 单链表的一个变形是单向循环链表，链表中最后一个节点的next域不再为None，而是指向链表的头节点。 操作:  is_empty() 判断链表是否为空 length() 返回链表的长度 travel() 遍历 add(item) 在头部添加一个节点 append(item) 在尾部添加一个节点 insert(pos, item) 在指定位置pos添加节点 remove(item) 删除一个节点 search(item) 查找节点是否存在  实现:   123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144class Node(object):    节点    def __init__(self, item):   self. item = item   self. next = Noneclass SinCycLinkedlist(object):    单向循环链表    def __init__(self):   self. _head = None def is_empty(self):      判断链表是否为空      return self. _head == None def length(self):      返回链表的长度      # 如果链表为空，返回长度0   if self. is_empty():     return 0   count = 1   cur = self. _head   while cur. next != self. _head:     count += 1     cur = cur. next   return count def travel(self):      遍历链表      if self. is_empty():     return   cur = self. _head   print cur. item,   while cur. next != self. _head:     cur = cur. next     print cur. item,   print    def add(self, item):      头部添加节点      node = Node(item)   if self. is_empty():     self. _head = node     node. next = self. _head   else:     #添加的节点指向_head     node. next = self. _head     # 移到链表尾部，将尾部节点的next指向node     cur = self. _head     while cur. next != self. _head:       cur = cur. next     cur. next = node     #_head指向添加node的     self. _head = node def append(self, item):      尾部添加节点      node = Node(item)   if self. is_empty():     self. _head = node     node. next = self. _head   else:     # 移到链表尾部     cur = self. _head     while cur. next != self. _head:       cur = cur. next     # 将尾节点指向node     cur. next = node     # 将node指向头节点_head     node. next = self. _head def insert(self, pos, item):      在指定位置添加节点      if pos &lt;= 0:     self. add(item)   elif pos &gt; (self. length()-1):     self. append(item)   else:     node = Node(item)     cur = self. _head     count = 0     # 移动到指定位置的前一个位置     while count &lt; (pos-1):       count += 1       cur = cur. next     node. next = cur. next     cur. next = node def remove(self, item):      删除一个节点      # 若链表为空，则直接返回   if self. is_empty():     return   # 将cur指向头节点   cur = self. _head   pre = None   # 若头节点的元素就是要查找的元素item   if cur. item == item:     # 如果链表不止一个节点     if cur. next != self. _head:       # 先找到尾节点，将尾节点的next指向第二个节点       while cur. next != self. _head:         cur = cur. next       # cur指向了尾节点       cur. next = self. _head. next       self. _head = self. _head. next     else:       # 链表只有一个节点       self. _head = None   else:     pre = self. _head     # 第一个节点不是要删除的     while cur. next != self. _head:       # 找到了要删除的元素       if cur. item == item:         # 删除         pre. next = cur. next         return       else:         pre = cur         cur = cur. next     # cur 指向尾节点     if cur. item == item:       # 尾部删除       pre. next = cur. next def search(self, item):      查找节点是否存在      if self. is_empty():     return False   cur = self. _head   if cur. item == item:     return True   while cur. next != self. _head:     cur = cur. next     if cur. item == item:       return True   return Falseif __name__ ==  __main__ : ll = SinCycLinkedlist() ll. add(1) ll. add(2) ll. append(3) ll. insert(2, 4) ll. insert(4, 5) ll. insert(0, 6) print  length: ,ll. length() ll. travel() print ll. search(3) print ll. search(7) ll. remove(1) print  length: ,ll. length() ll. travel()   "
    }, {
    "id": 24,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/",
    "title": "数据结构与算法-双向链表",
    "body": "2017/12/01 - 一种更复杂的链表是“双向链表”或“双面链表”。每个节点有两个链接：一个指向前一个节点，当此节点为第一个节点时，指向空值；而另一个指向下一个节点，当此节点为最后一个节点时，指向空值。 操作:  is_empty() 链表是否为空 length() 链表长度 travel() 遍历链表 add(item) 链表头部添加 append(item) 链表尾部添加 insert(pos, item) 指定位置添加 remove(item) 删除节点 search(item) 查找节点是否存在  实现:   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Node(object):    双向链表节点    def __init__(self, item):   self. item = item   self. next = None   self. prev = Noneclass DLinkList(object):    双向链表    def __init__(self):   self. _head = None def is_empty(self):      判断链表是否为空      return self. _head == None def length(self):      返回链表的长度      cur = self. _head   count = 0   while cur != None:     count += 1     cur = cur. next   return count def travel(self):      遍历链表      cur = self. _head   while cur != None:     print cur. item,     cur = cur. next   print    def add(self, item):      头部插入元素      node = Node(item)   if self. is_empty():     # 如果是空链表，将_head指向node     self. _head = node   else:     # 将node的next指向_head的头节点     node. next = self. _head     # 将_head的头节点的prev指向node     self. _head. prev = node     # 将_head 指向node     self. _head = node def append(self, item):      尾部插入元素      node = Node(item)   if self. is_empty():     # 如果是空链表，将_head指向node     self. _head = node   else:     # 移动到链表尾部     cur = self. _head     while cur. next != None:       cur = cur. next     # 将尾节点cur的next指向node     cur. next = node     # 将node的prev指向cur     node. prev = cur def search(self, item):      查找元素是否存在      cur = self. _head   while cur != None:     if cur. item == item:       return True     cur = cur. next   return False    指定位置插入节点:    12345678910111213141516171819202122def insert(self, pos, item):       在指定位置添加节点       if pos &lt;= 0:      self. add(item)    elif pos &gt; (self. length()-1):      self. append(item)    else:      node = Node(item)      cur = self. _head      count = 0      # 移动到指定位置的前一个位置      while count &lt; (pos-1):        count += 1        cur = cur. next      # 将node的prev指向cur      node. prev = cur      # 将node的next指向cur的下一个节点      node. next = cur. next      # 将cur的下一个节点的prev指向node      cur. next. prev = node      # 将cur的next指向node      cur. next = node删除元素: 12345678910111213141516171819202122232425def remove(self, item):       删除元素       if self. is_empty():      return    else:      cur = self. _head      if cur. item == item:        # 如果首节点的元素即是要删除的元素        if cur. next == None:          # 如果链表只有这一个节点          self. _head = None        else:          # 将第二个节点的prev设置为None          cur. next. prev = None          # 将_head指向第二个节点          self. _head = cur. next        return      while cur != None:        if cur. item == item:          # 将cur的前一个节点的next指向cur的后一个节点          cur. prev. next = cur. next          # 将cur的后一个节点的prev指向cur的前一个节点          cur. next. prev = cur. prev          break        cur = cur. next测试: 123456789101112131415if __name__ ==  __main__ :  ll = DLinkList()  ll. add(1)  ll. add(2)  ll. append(3)  ll. insert(2, 4)  ll. insert(4, 5)  ll. insert(0, 6)  print  length: ,ll. length()  ll. travel()  print ll. search(3)  print ll. search(4)  ll. remove(1)  print  length: ,ll. length()  ll. travel()"
    }, {
    "id": 25,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8(%E4%BA%8C)/",
    "title": "数据结构与算法-单向链表(二)",
    "body": "2017/11/10 - 头部添加元素: 12345678def add(self, item):     头部添加元素     # 先创建一个保存item值的节点  node = SingleNode(item)  # 将新节点的链接域next指向头节点，即_head指向的位置  node. next = self. _head  # 将链表的头_head指向新节点  self. _head = node尾部添加元素: 123456789101112def append(self, item):       尾部添加元素       node = SingleNode(item)    # 先判断链表是否为空，若是空链表，则将_head指向新节点    if self. is_empty():      self. _head = node    # 若不为空，则找到尾部，将尾节点的next指向新节点    else:      cur = self. _head      while cur. next != None:        cur = cur. next      cur. next = node指定位置添加元素: 12345678910111213141516171819202122def insert(self, pos, item):       指定位置添加元素       # 若指定位置pos为第一个元素之前，则执行头部插入    if pos &lt;= 0:      self. add(item)    # 若指定位置超过链表尾部，则执行尾部插入    elif pos &gt; (self. length()-1):      self. append(item)    # 找到指定位置    else:      node = SingleNode(item)      count = 0      # pre用来指向指定位置pos的前一个位置pos-1，初始从头节点开始移动到指定位置      pre = self. _head      while count &lt; (pos-1):        count += 1        pre = pre. next      # 先将新节点node的next指向插入位置的节点      node. next = pre. next      # 将插入位置的前一个节点的next指向新节点      pre. next = node删除节点: 12345678910111213141516171819def remove(self,item):       删除节点       cur = self. _head    pre = None    while cur != None:      # 找到了指定元素      if cur. item == item:        # 如果第一个就是删除的节点        if not pre:          # 将头指针指向头节点的后一个节点          self. _head = cur. next        else:          # 将删除位置前一个节点的next指向删除位置的后一个节点          pre. next = cur. next        break      else:        # 继续按链表后移节点        pre = cur        cur = cur. next查找节点是否存在: 12345678def search(self,item):       链表查找节点是否存在，并返回True或者False       cur = self. _head    while cur != None:      if cur. item == item:        return True      cur = cur. next    return False测试: 12345678910111213if __name__ ==  __main__ :  ll = SingleLinkList()  ll. add(1)  ll. add(2)  ll. append(3)  ll. insert(2, 4)  print  length: ,ll. length()  ll. travel()  print ll. search(3)  print ll. search(5)  ll. remove(1)  print  length: ,ll. length()  ll. travel()链表与顺序表的对比链表失去了顺序表随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大，但对存储空间的使用要相对灵活。       操作   链表   顺序表         访问元素   O(n)   O(1)       在头部插入/删除   O(1)   O(n)       在尾部插入/删除   O(n)   O(1)       在中间插入/删除   O(n)   O(n)   注意虽然表面看起来复杂度都是 O(n)，但是链表和顺序表在插入和删除时进行的是完全不同的操作。链表的主要耗时操作是遍历查找，删除和插入操作本身的复杂度是O(1)。顺序表查找很快，主要耗时的操作是拷贝覆盖。因为除了目标元素在尾部的特殊情况，顺序表进行插入和删除时需要对操作点之后的所有元素进行前后移位操作，只能通过拷贝和覆盖的方法进行。 "
    }, {
    "id": 26,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8(%E4%B8%80)/",
    "title": "数据结构与算法-单向链表(一)",
    "body": "2017/11/01 - 顺序表的构建需要预先知道数据大小来申请连续的存储空间，而在进行扩充时又需要进行数据的搬迁，所以使用起来并不是很灵活。 链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。 链表的定义: 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是不像顺序表一样连续存储数据，而是在每一个节点（数据存储单元）里存放下一个节点的位置信息（即地址）。 单向链表: 单向链表也叫单链表，是链表中最简单的一种形式，它的每个节点包含两个域，一个信息域（元素域）和一个链接域。这个链接指向链表中的下一个节点，而最后一个节点的链接域则指向一个空值。  表元素域elem用来存放具体的数据。 链接域next用来存放下一个节点的位置（python中的标识） 变量p指向链表的头节点（首节点）的位置，从p出发能找到表中的任意节点。节点实现: 1234567class SingleNode(object):     单链表的结点     def __init__(self,item):    # _item存放数据元素    self. item = item    # _next是下一个节点的标识    self. next = None单链表的操作:  is_empty() 链表是否为空 length() 链表长度 travel() 遍历整个链表 add(item) 链表头部添加元素 append(item) 链表尾部添加元素 insert(pos, item) 指定位置添加元素 remove(item) 删除节点 search(item) 查找节点是否存在## 12345678910111213141516171819202122232425class SingleLinkList(object):     单链表     def __init__(self):    self. _head = None  def is_empty(self):       判断链表是否为空       return self. _head == None  def length(self):       链表长度       # cur初始时指向头节点    cur = self. _head    count = 0    # 尾节点指向None，当未到达尾部时    while cur != None:      count += 1      # 将cur后移一个节点      cur = cur. next    return count  def travel(self):       遍历链表       cur = self. _head    while cur != None:      print cur. item,      cur = cur. next    print   "
    }, {
    "id": 27,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%A1%BA%E5%BA%8F%E8%A1%A8/",
    "title": "数据结构与算法-顺序表",
    "body": "2017/10/19 - 在程序中，经常需要将一组（通常是同为某个类型的）数据元素作为整体管理和使用，需要创建这种元素组，用变量记录它们，传进传出函数等。一组数据中包含的元素个数可能发生变化（可以增加或删除元素）。 对于这种需求，最简单的解决方案便是将这样一组元素看成一个序列，用元素在序列里的位置和顺序，表示实际应用中的某种有意义的信息，或者表示数据之间的某种关系。 这样的一组序列元素的组织形式，我们可以将其抽象为线性表。一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。线性表是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。 根据线性表的实际存储方式，分为两种实现模型：  顺序表，将元素顺序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序自然表示。 链表，将元素存放在通过链接构造起来的一系列存储块中。顺序表的基本形式: 图a表示的是顺序表的基本形式，数据元素本身连续存储，每个元素所占的存储单元大小固定相同，元素的下标是其逻辑地址，而元素存储的物理地址（实际内存地址）可以通过存储区的起始地址Loc (e0)加上逻辑地址（第i个元素）与存储单元大小（c）的乘积计算而得，即： Loc(ei) = Loc(e0) + c*i 故，访问指定元素时无需从头遍历，通过计算便可获得对应地址，其时间复杂度为O(1)。 如果元素的大小不统一，则须采用图b的元素外置的形式，将实际数据元素另行存储，而顺序表中各单元位置保存对应元素的地址信息（即链接）。由于每个链接所需的存储量相同，通过上述公式，可以计算出元素链接的存储位置，而后顺着链接找到实际存储的数据元素。注意，图b中的c不再是数据元素的大小，而是存储一个链接地址所需的存储量，这个量通常很小。 图b这样的顺序表也被称为对实际数据的索引，这是最简单的索引结构。 顺序表的结构: 一个顺序表的完整信息包括两部分，一部分是表中的元素集合，另一部分是为实现正确操作而需记录的信息，即有关表的整体情况的信息，这部分信息主要包括元素存储区的容量和当前表中已有的元素个数两项。 顺序表的两种基本实现方式: 图a为一体式结构，存储表信息的单元与元素存储区以连续的方式安排在一块存储区里，两部分数据的整体形成一个完整的顺序表对象。 一体式结构整体性强，易于管理。但是由于数据元素存储区域是表对象的一部分，顺序表创建后，元素存储区就固定了。 图b为分离式结构，表对象里只保存与整个表有关的信息（即容量和元素个数），实际数据元素存放在另一个独立的元素存储区里，通过链接与基本表对象关联。 元素存储区替换: 一体式结构由于顺序表信息区与数据区连续存储在一起，所以若想更换数据区，则只能整体搬迁，即整个顺序表对象（指存储顺序表的结构信息的区域）改变了。 分离式结构若想更换数据区，只需将表信息区中的数据区链接地址更新即可，而该顺序表对象不变。 元素存储区扩充: 采用分离式结构的顺序表，若将数据区更换为存储空间更大的区域，则可以在不改变表对象的前提下对其数据存储区进行了扩充，所有使用这个表的地方都不必修改。只要程序的运行环境（计算机系统）还有空闲存储，这种表结构就不会因为满了而导致操作无法进行。人们把采用这种技术实现的顺序表称为动态顺序表，因为其容量可以在使用中动态变化。 扩充的两种策略:    每次扩充增加固定数目的存储位置，如每次扩充增加10个元素位置，这种策略可称为线性增长。特点：节省空间，但是扩充操作频繁，操作次数多。     每次扩充容量加倍，如每次扩充增加一倍存储空间。特点：减少了扩充操作的执行次数，但可能会浪费空间资源。以空间换时间，推荐的方式。  顺序表的操作: 增加元素: 如图所示，为顺序表增加新元素111的三种方式a. 尾端加入元素，时间复杂度为O(1) b. 非保序的加入元素（不常见），时间复杂度为O(1) c. 保序的元素加入，时间复杂度为O(n) 删除元素: a. 删除表尾元素，时间复杂度为O(1) b. 非保序的元素删除（不常见），时间复杂度为O(1) c. 保序的元素删除，时间复杂度为O(n) Python中的顺序表: Python中的list和tuple两种类型采用了顺序表的实现技术，具有前面讨论的顺序表的所有性质。 tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似。 list的基本实现技术: Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：  基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)； 为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。 在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list. append(x) （或 list. insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。 在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。 "
    }, {
    "id": 28,
    "url": "http://localhost:4000/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BC%95%E5%85%A5/",
    "title": "数据结构与算法-引入",
    "body": "2017/09/20 - 理解数据结构与算法: 如果将最终写好运行的程序比作战场，我们码农便是指挥作战的将军，而我们所写的代码便是士兵和武器。 那么数据结构和算法是什么？答曰：兵法！ 我们可以不看兵法在战场上肉搏，如此，可能会胜利，可能会失败。即使胜利，可能也会付出巨大的代价。我们写程序亦然：没有看过数据结构和算法，有时面对问题可能会没有任何思路，不知如何下手去解决；大部分时间可能解决了问题，可是对程序运行的效率和开销没有意识，性能低下；有时会借助别人开发的利器暂时解决了问题，可是遇到性能瓶颈的时候，又不知该如何进行针对性的优化。 如果我们常看兵法，便可做到胸有成竹，有时会事半功倍！同样，如果我们常看数据结构与算法，我们写程序时也能游刃有余、明察秋毫，遇到问题时亦能入木三分、迎刃而解。 故，数据结构和算法是一名程序开发人员的必备基本功 引入: 先来看一道题: 如果 a+b+c=1000，且 a^2+b^2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合? 第一次尝试: 1234567891011import timestart_time = time. time()# 注意是三重循环for a in range(0, 1001):  for b in range(0, 1001):    for c in range(0, 1001):      if a**2 + b**2 == c**2 and a+b+c == 1000:        print( a, b, c: %d, %d, %d  % (a, b, c))end_time = time. time()print( elapsed: %f  % (end_time - start_time))print( complete! )运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 214. 583347complete!注意运行时间为：214. 583347秒 第二次尝试: 1234567891011import timestart_time = time. time()# 注意是两重循环for a in range(0, 1001):  for b in range(0, 1001-a):    c = 1000 - a - b    if a**2 + b**2 == c**2:      print( a, b, c: %d, %d, %d  % (a, b, c))end_time = time. time()print( elapsed: %f  % (end_time - start_time))print( complete! )运行结果： 123456a, b, c: 0, 500, 500a, b, c: 200, 375, 425a, b, c: 375, 200, 425a, b, c: 500, 0, 500elapsed: 0. 182897complete!注意运行的时间:0. 182897秒 算法的概念: 算法是计算机处理信息的本质，因为计算机程序本质上是一个算法来告诉计算机确切的步骤来执行一个指定的任务。一般地，当算法在处理信息时，会从输入设备或数据的存储地址读取数据，把结果写入输出设备或某个存储地址供以后再调用。 算法是独立存在的一种解决问题的方法和思想。 对于算法而言，实现的语言并不重要，重要的是思想。 算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等） 算法的五大特性:  输入: 算法具有0个或多个输入 输出: 算法至少有1个或多个输出 有穷性: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成 确定性：算法中的每一步都有确定的含义，不会出现二义性 可行性：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成算法效率衡量: 执行时间反应算法效率: 对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214. 583347秒相比于0. 182897秒），由此我们可以得出结论：实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。 单靠时间值绝对可信吗？: 假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214. 583347秒快多少。 单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！ 程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？ 时间复杂度与“大O记法”: 我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。 对于算法的时间效率，我们可以用“大O记法”来表示。 “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c&gt;0，使得对于充分大的n总有f(n)&lt;=c*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n) 如何理解“大O记法”: 对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为3n2和100n2属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为n2级。 最坏时间复杂度: 分析算法时，存在几种可能的考虑： 算法完成工作最少需要多少基本操作，即最优时间复杂度算法完成工作最多需要多少基本操作，即最坏时间复杂度算法完成工作平均需要多少基本操作，即平均时间复杂度对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。 对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。 对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。 因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。 时间复杂度的几条基本计算规则:  基本操作，即只有常数项，认为其时间复杂度为O(1) 顺序结构，时间复杂度按加法进行计算 循环结构，时间复杂度按乘法进行计算 分支结构，时间复杂度取最大值 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略 在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度算法分析: 第一次尝试的算法核心部分: 123456for a in range(0, 1001):  for b in range(0, 1001):    for c in range(0, 1001):      if a**2 + b**2 == c**2 and a+b+c == 1000:        print( a, b, c: %d, %d, %d  % (a, b, c))时间复杂度：T(n) = O(nnn) = O(n3) 第二次尝试的算法核心部分: 123456for a in range(0, 1001):  for b in range(0, 1001-a):    c = 1000 - a - b    if a**2 + b**2 == c**2:      print( a, b, c: %d, %d, %d  % (a, b, c))时间复杂度：T(n) = O(nn(1+1)) = O(n*n) = O(n2)由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。 "
    }, {
    "id": 29,
    "url": "http://localhost:4000/Spring-Boot%E8%B8%A9%E5%9D%91%E4%B8%89/",
    "title": "Spring Boot踩坑之路三",
    "body": "2017/07/20 - 使用JPA进行CRUD以及IDEA 中 Devtools热部署配置 Spring Boot进行简单的CRUD: 只需要定义一个repository继承PagingAndSortingRepository、PagingAndSortingRepository或JpaRepository就可以使用Spring Data为我们提供的CRUD。三个接口都是做数据操作的，下面解释了他们三个的区别，我们应该根据需求灵活使用。 JpaRepository继承了PagingAndSortingRepository，PagingAndSortingRepository继承了CrudRepository 他们的主要功能是： CrudRepository 提供主要的CRUD方法 PagingAndSortingRepository 提供分页和排序的方法 JpaRepository 提供一些JPA关联方法，比如批量删除数据 因为上述的继承关系，JpaRepository拥有PagingAndSortingRepository和CrudRepository 的所有方法。所以如果你不需要JpaRepository和PagingAndSortingRepository提供的方法的话，请使用CrudRepository Spring Boot IDEA 热部署: 首先要对IDEA进行必要配置，否则热部署不起作用 IDEA自动构建: 修改IDEA注册信息: 输入命令Ctrl + Shift + A 然后搜索registry回车 添加devtools依赖: 添加依赖，重启项目，然后试着修改java文件，自动重新部署成功 12345&lt;dependency&gt;	&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;	&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;	&lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;"
    }, {
    "id": 30,
    "url": "http://localhost:4000/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/",
    "title": "Spring事务处理",
    "body": "2017/03/20 - 什么是软件框架: 软件框架（Software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。 框架的功能类似于基础设施，与具体的软件应用无关，但是提供并实现最为基础的软件架构和体系。软件开发者通常依据特定的框架实现更为复杂的商业运用和业务逻辑。这样的软件应用可以在支持同一种框架的软件系统中运行。 对于Spring框架来说：Spring是一套建筑标准，比如承重标准、丈量标准，通风标准等，并规范了结构：框架式结构，浇筑式结构，且定义了建筑的每个组成部分名字与接口，比如电力系统的接口是220v，通风系统的孔径必须符合ISO标准等。 攻城狮是建筑的设计师，在基础框架与标准下，设计出符合客户要求的建筑图纸，并决定了使用哪个厂家生产的水泥，砖块，和电力，通风等系统。 程序猿就是泥瓦匠，电工，依照图纸，完成各个部分的堆砌，安装，部署，装饰等等。说白了，程序猿就是一板砖的。 IOC: 所谓控制反转，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们可配置的文件。 AOP: 面向切面编程，作为对面向对象的补充，广泛应用于处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。 什么是事务: 逻辑上的一组操作，这组操作要么全部成功，要么全部失败。 事务的特性: 事务有四大特性：原子性、一致性、隔离性、持久性。 原子性是指事务是一个不可分割的工作单位，事务中的操作，要么都发生，要么都失败一致性指的是事务前后数据完整性保持一致隔离性是指一个用户事务进行时，不能受到其他事务的影响。（通过隔离级别处理）持久性是指一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。 事务接口: Spring为我们提供事务管理主要的接口，一共有三个 事务管理器：PlatformTransactionManager 事务定义信息（隔离、传播、超时、只读）：TransactionDefinition 事务具体运行状态：TransactionStatus: 事务具体运行状态（TransactionStatus）TransactionStatus接口定义了获得和判断事物状态的方法 事务管理器（PlatformTransactionManager）: Spring会根据持久层不同的实习选择不同的事务管理器 DataSourceTransactionManager ： JDBC和MyBatisHibernateTransactionManager ： Hibernate所以Spring处理MyBatis和JDBC的事务使用的是一样的方法，而Hibernate是另外一种实现方法 事务定义信息（TransactionDefinition）:    ISOLATION 开头定义的是事务的隔离级别     PROPAGATION 开头定义的是事务的传播行为     TIMEOUT 开头定义的是事务的超时信息  ISOLATION: 事务的隔离级别，主要是解决在实际开发中可能遇到的三个问题：    脏读，A进行update、insert时候，B读取了中间状态不知道对不对的值；     不可重复读，B在A 的update操作前后，读到的数据不一致；     幻读，B在A的insert操作前后，读到了的数据不一致  MySQL底层采用的是REPEATABLE_READ隔离级别Oracle底层采用的是READ_COMMITTED隔离级别 PROPAGATION: 事务的传播行为：主要是解决业务层方法之间的相互调用的问题(比如一个业务需求为同时调用A和B两个数据库操作)事务的传播行为有七种，又分为三类：第一类共同点：如果 A 方法中有事务，则调用 B 方法时就用该事务，即：A和B方法在同一个事务中。PROPAGATION_REQUIRED：如果 A 方法中没有事务，则调用 B 方法时就创建一个新的事务，即：A和B方法在同一个事务中。PROPAGATION_SUPPORTS：如果 A 方法中没有事务，则调用 B 方法时就不使用该事务。PROPAGATION_MANDATORY：如果 A 方法中没有事务，则调用 B 方法时就抛出异常。 第二类共同点：A方法和B方法没有在同一个事务里面。PROPAGATION_REQUIRES_NEW：如果 A 方法中有事务，则挂起并新建一个事务给 B 方法。PROPAGATION_NOT_SUPPORTED：如果 A 方法中有事务，则挂起。PROPAGATION_NEVER：如果 A 方法中有事务，则报异常。 第三类：如果 A 方法有的事务执行完，设置一个保存点，如果 B 方法中事务执行失败，可以滚回保存点或初始状态。PROPAGATION_NESTED ：如果当前事务存在，则嵌套事务执行 "
    }, {
    "id": 31,
    "url": "http://localhost:4000/Spring-Boot%E8%B8%A9%E5%9D%91%E4%BA%8C/",
    "title": "Spring Boot踩坑之路二",
    "body": "2017/02/20 - 上篇文章使用Maven构建项目并成功运行hello，让我初步感受Spring Boot的强大。本次我将使用更优雅的方式创建Spring Boot项目并学习它对数据库的相关操作 更优雅的创建Spring Boot项目: 上篇文章的方法是建立Maven项目、配置pom. xml、建立application类。当用到的开源项目多的时候，每次配置pom. xml很会很麻烦。使用IDEA为我们提供的Spring Initializr可以快速创建Spring Boot项目，我们将不再需要之前繁琐的步骤 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;&lt;project xmlns= http://maven. apache. org/POM/4. 0. 0  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance   xsi:schemaLocation= http://maven. apache. org/POM/4. 0. 0 http://maven. apache. org/xsd/maven-4. 0. 0. xsd &gt;  &lt;modelVersion&gt;4. 0. 0&lt;/modelVersion&gt;  &lt;groupId&gt;com. app&lt;/groupId&gt;  &lt;artifactId&gt;demo&lt;/artifactId&gt;  &lt;version&gt;0. 0. 1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;name&gt;demo&lt;/name&gt;  &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;  &lt;parent&gt;    &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1. 5. 1. RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;  &lt;/parent&gt;  &lt;properties&gt;    &lt;project. build. sourceEncoding&gt;UTF-8&lt;/project. build. sourceEncoding&gt;    &lt;project. reporting. outputEncoding&gt;UTF-8&lt;/project. reporting. outputEncoding&gt;    &lt;java. version&gt;1. 8&lt;/java. version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;plugins&gt;      &lt;plugin&gt;        &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;      &lt;/plugin&gt;    &lt;/plugins&gt;  &lt;/build&gt;&lt;/project&gt;Spring Boot JPA: 回归主题，Spring Boot是如何操作数据库的呢，本次以Oracle数据库为例介绍Spring Boot的JPA操作（Hibernate版） 连接数据库: 添加依赖(需要添加两个依赖，一个是Spring Boot操作数据库的依赖，还有一个是数据库驱动) 123456789101112131415161718 &lt;!--Spring Boot java persist API dependency--&gt; &lt;dependency&gt;   &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Oracle数据库驱动 --&gt; &lt;!-- Oracle Driver Dependency which located in local repository --&gt; &lt;dependency&gt;  &lt;groupId&gt;com. oracle&lt;/groupId&gt;  &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;  &lt;version&gt;11. 2. 0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySql 驱动，maven官方就有，无需本地添加&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;--&gt;注意: 由于商业版权和版本的问题，Maven中心仓库并不支持Oracle驱动包，所以需要根据自己的Oracle进行手动安装 首先从Oracle安装目录中找到本地Oracle驱动，以我为例： E:\app\Administrator\product\11. 2. 0\dbhome_1\jdbc\lib进入我的路径将ojdbc添加到本地Maven仓库 mvn install:install-file -DgroupId=com. oracle -DartifactId=ojdbc6 -Dversion=11. 2. 0. 1. 0 -Dpackaging=jar -Dfile=ojdbc6. jar– 指定坐标、打包格式、打包文件回车安装 添加属性配置: 加载了SpringBoot连接和驱动依赖当然不能让我们连接到数据库，我们还需要告诉Spring Boot一些数据库连接信息 我们只需要在application. properties文件中添加就可以了 基本的连接信息，指定数据源: spring. datasource. url = jdbc:oracle:thin:@127. 0. 0. 1:1521:orclspring. datasource. username = scottspring. datasource. password = orclspring. datasource. driverClassName = oracle. jdbc. OracleDriver java持久化API Hibernate配置模式: spring. jpa. hibernate. ddl-auto = update新建实体类，并交给Hibernate 维护 1234567891011121314151617181920212223242526272829package com. example. entity;import javax. persistence. *;@Entity@Table(name =  demo_user )public class User {  @Id @GeneratedValue(strategy = GenerationType. SEQUENCE,generator =  seq_user )  @SequenceGenerator(name =  seq_user ,sequenceName =  seq_user )  private int id;  private String userName;  private String password;  public int getId() {    return id;  }  public void setId(int id) {    this. id = id;  }  public String getUserName() {    return userName;  }  public void setUserName(String userName) {    this. userName = userName;  }  public String getPassword() {    return password;  }  public void setPassword(String password) {    this. password = password;  }}最后启动项目，是不是发现数据库里面多了个demo_user表了呢 遇到的问题: 安装完成ojdbc驱动在pom. xml中引用仍然无效 1创建项目的时候选择了默认C盘. m2下的仓库，而我的Maven仓库配置在D盘，所以安装的驱动的时候安装到了D盘的仓库，使用的却是系统默认的仓库，尴尬-_-!在全部配置好之后启动工程会把表建立出来，但是当再次启动的时候竟然报了对象已由现有名称引用异常 12通过log观察，他又执行了一次建表语句。我多次检查自己的配置，确实是spring. jpa. hibernate. ddl-auto = update没问题。到网上查了半天，也没找到有相似问题的结果。出去吹个风，回来发现我需要引用的驱动jar包是ojdbc6，而在pom中引入的是服务器数据库的ojdbc14。白白浪费了这么长时间&lt;(￣3￣)&gt; 。"
    }, {
    "id": 32,
    "url": "http://localhost:4000/Spring-Boot%E8%B8%A9%E5%9D%91%E4%B8%80/",
    "title": "Spring Boot踩坑之路一",
    "body": "2017/02/05 -  Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 旨在简化创建产品级的 Spring应用和服务。Spring Boot 引导优先于配置，它可以让你避免繁杂的配置，尽可能的帮助你快速建站。 为什么使用Spring Boot: 经过十多年的发展Spring家族已经壮大，要灵活使用Spring家族的产品已经变得有些困难，尤其是要维护一大堆的配置文件，在项目开发中令人头疼。Spring Boot解决了这个问题，并大大简化了我们的开发成本 其优点如下::  不用看一大坨的xml。用java config可以让你很容易明白一些框架的关键 Spring Boot 要解决的问题, 精简配置是一方面, 另外一方面是如何方便的让spring生态圈和其他工具链整合(比如redis, email, elecsearch) 配合各种starter使用，基本上可以做到自动化配置 配合Maven或Gradle等构件工具打成Jar包后，Java -jar 简化部署运行建立maven web项目: 使用maven建立web项目，并参考官方文档进行版本选择和pom配置 官方maven配置，请根据需求选择版本 POM中添加parent标签添加parent后添加相关依赖不需要version 12345&lt;parent&gt;  &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;1. 4. 2. RELEASE&lt;/version&gt;&lt;/parent&gt;添加依赖: web工程的依赖，包括spring mvc tomcat等，spring boot会在需要时使用 1234&lt;dependency&gt; &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;添加插件: 用来在main方法中启动工程 123456&lt;plugins&gt;  &lt;plugin&gt;   &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-maven-plugin &lt;/artifactId&gt;  &lt;/plugin&gt;&lt;/plugins&gt;编写代码 HELLO WORLD: 123456789101112// 其中@SpringBootApplication申明让spring boot自动给程序进行必要的配置，等价于使用@Configuration，@EnableAutoConfiguration和@ComponentScan@RestController@SpringBootApplicationpublic class HelloWorld {  @RequestMapping( / )  public String hello() {    return  Hello World ;  }  public static void main(String[] args) {    SpringApplication. run(HelloWorld. class,args);  }}检验成果运行main函数之后访问http://localhost:8080/即可看到结果 我遇到的问题: 问题出现在我建立maven项目编写java代码的时候在默认包中写的application类，并没有建立包。这种做法让Spring Boot每次都会扫描默认类及下属的所有类，浪费大量时间。所以在启动时会报警告，启动不成功 Your Application class should be placed in a specific package and not in the default (top-level) package. For example, put it in com. example and place all your application code in this package or in sub-packages like com. example. foo and com. example. bar. Placing your Application class in the default package, i. e. directly in src/main/java isn’t a good idea and it will almost certainly cause your application to fail to start. If you do so, you should see this warning: 1** WARNING ** : Your ApplicationContext is unlikely to start due to a @ComponentScan of the default package. "
    }, {
    "id": 33,
    "url": "http://localhost:4000/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/",
    "title": "Java虚拟机",
    "body": "2017/02/02 - 跨平台的含义: Java的跨平台是“一次编译，到处运行”。Java在编译的时候没有编译成指定CPU类型的汇编代码，也没有和具体操作系统的系统调用相关联，所以编译出来的结果是和CPU，操作系统都不相关的。Java编译出来的是一种字节码，这种字节码必须在Java的虚拟机上才能运行，Java虚拟机会屏蔽不同操作系统，CPU之间的差异。 C编译出来后，就是指定CPU类型的汇编代码，编译过程中肯定也要和具体操作系统的系统库相关连，所以做不到Java那种跨平台。但是，如果写的C代码，没有直接调用任何系统调用，这个代码在不同的平台下都能编译，也能运行。和Java的区别是，C要在不同平台上分别编译。 有些语言如JavaScript，Python等，他们是解释执行的，不存在编译过程，所以也能跨平台，前提是必须要有一个对应的解释器，PHP好像也是解释性的。 了解虚拟机: 当用户量达到一定数量的时候，程序就很有可能出现各种问题（缓慢，死锁等）一般情况下，企业都会通过提升硬件配置的方法尝试解决问题，但对于运行在JVM 上的 java来说，如果不了解JVM的运行原理，单纯的提升硬件配置很有可能对问题的解决改善很小，甚至没有改善 Java技术体系: 由SUN公司官方定义：  Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件 Java API类库 来自商业机构或开源社区的Java类库"
    }, {
    "id": 34,
    "url": "http://localhost:4000/Maven%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92/",
    "title": "Maven配置解析与依赖传递",
    "body": "2017/01/24 - Maven的核心配置文件pom. xml的解析与其依赖传递特性,并简单介绍Maven在Web开发中的配置操作过程 12Maven安装本地jar备忘mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jarpom. xml解析: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;name&gt;项目的描述名&lt;/name&gt;&lt;url&gt;项目的地址&lt;/url&gt;&lt;description&gt;项目描述&lt;/description&gt;&lt;developers&gt;开发人员信息&lt;/developers&gt;&lt;licenses&gt;许可证信息&lt;/licenses&gt;&lt;!-- 依赖列表 --&gt;&lt;dependencies&gt;&lt;!-- 依赖项 --&gt;  &lt;dependency&gt;    &lt;!--指定坐标--&gt;    &lt;groupId&gt;反写公司网址+项目名&lt;/groupId&gt;    &lt;artifactId&gt;项目名+模块名&lt;/artifactId&gt;    &lt;version&gt;版本0. 0. 0（大版本+分支版本+小版本）&lt;/version&gt;    &lt;type&gt;类型&lt;/type&gt;    &lt;scope&gt;依赖的范围&lt;/scope&gt;    &lt;optional&gt;设置依赖是否可选，默认是false&lt;/optional&gt;    &lt;!-- 排除依赖传递列表 --&gt;    &lt;exclusions&gt;      &lt;exclusion&gt;&lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 依赖的管理，一般定义在父模块中，由子模块去继承 --&gt;&lt;dependencyManagement&gt;  &lt;dependencies&gt;    &lt;dependency&gt;&lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 对构建行为提供相应的支持 --&gt;&lt;build&gt;&lt;!-- 插件列表 --&gt;  &lt;plugins&gt;    &lt;plugin&gt;    &lt;!-- 指定坐标 --&gt;      &lt;groupId&gt;反写公司网址+项目名&lt;/groupId&gt;      &lt;artifactId&gt;项目名+模块名&lt;/artifactId&gt;      &lt;version&gt;版本0. 0. 0（大版本+分支版本+小版本）&lt;/version&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;&lt;!-- 一般在子模块中指定所继承的父模块 --&gt;&lt;!-- 继承后拥有父模块的特性 --&gt;&lt;parent&gt;&lt;/parent&gt;&lt;!-- 模块列表 --&gt;&lt;modules&gt;  &lt;module&gt;&lt;/module&gt;&lt;/modules&gt;&lt;!--作用域--&gt;&lt;scope&gt;&lt;!--  scope作用域简介  1. compile：默认范围，编译测试运行都有效  2. provided：在编译和测试时有效  3. runtime：在测试和运行时有效  4. test:只在测试时有效  5. system:在编译和测试时有效，与本机系统关联，可移植性差  6. import:导入的范围，它只使用在dependencyManagement中，表示从其他的pom中导入dependency的配置--&gt;Maven依赖传递: 假设B项目依赖A项目，C项目又依赖B项目，那么在C项目中运行compile时，在引进B项目的同时，自动就把A项目也引进来了。如果不想将A项目导入的话，可以使用exclusions下设置exclusion，然后将A项目的坐标添加即可。 Ps：可以在settings. xml中的profile结点，来更改默认的Maven使用的jdk版本，否则将显示默认的1. 5版本。 123456789101112&lt;profile&gt;  &lt;id&gt;jdk-1. 7&lt;/id&gt;  &lt;activation&gt;    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;  &lt;jdk&gt;1. 7&lt;/jdk&gt;  &lt;/activation&gt;  &lt;properties&gt;    &lt;maven. compiler. source&gt;1. 7&lt;/maven. compiler. source&gt;    &lt;maven. compiler. target&gt;1. 7&lt;/maven. compiler. target&gt;    &lt;maven. compiler. compilerVersion&gt;1. 7&lt;/maven. compiler. compilerVersion&gt;  &lt;/properties&gt;&lt;/profile&gt;依赖冲突: 如果A和B依赖了一个不同版本的相同的构件C。 如果A和B依赖了一个不同版本的相同的构件C。: 会优先解析路径短的版本。A -&gt; B -&gt; C -&gt; X(jar)A -&gt; D -&gt; X(jar) 优先解析短的 先声明先优先: 如果路径长度相同，则谁先声明，先解析谁。 聚合: 如果项目D依赖项目C，项目C依赖项目B，项目B依赖项目A，我们需要一个个安装这项项目，在Maven中有一种方式可以将多个项目一次性安装，这就是聚合的概念。 简单讲就是，需要人工多次操作的，只要Maven能理解，一次性告诉他，他就能帮我们做这件单调烦人的事情了。使用这个标签 继承: 多次使用到的依赖，比如：单元测试，没有必要在所有的项目中都引用一下，此时就可以采用继承的方式来实现，先来一个父级的POM. XML然后再继承此POM. XML。使用标签 Maven 配置web项目实例:    打开Eclipse     创建Maven项目，选择archetype-webapp模板     解决Servlet没有生命依赖的问题，在pom. xml中添加servlet的依赖，可以去中央仓库选择servlet版本例如：```xml  javax. servletjavax. servlet-api4. 0. 0-b011234567891011121314151617181920212223242526272829303132333435363738394. 手工完善Maven约定好的目录结构可以在navigator窗口中手动新建. . /src/main/java. . /src/test/java5. Project Explorer中更新项目6. 创建项目的输出目录build path中设置输出路径output folder，确保每个module都输出在. . /tartet/classes目录中7. 将Maven项目转换为Web项目右击-属性-project facets-勾选动态模板（Dynamic Web Module）8. 修改部署时配置去掉多余的配置项例如：测试代码右击-属性-Deployment Assembly-删除多余的配置项（测试代码）9. 使用package命令打包项目—使用jetty这个插件（在Maven的中央插件库中寻找）作为Web容器，在中央仓库查找jetty的plugin坐标配置到pom. xml中#### pom. xml例子```xml&lt;build&gt;  &lt;finalName&gt;webbproject-demo&lt;/finalName&gt;  &lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;org. apache. tomcat. maven&lt;/groupId&gt;        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;2. 2&lt;/version&gt;    &lt;executions&gt;      &lt;execution&gt;        &lt;phase&gt;package&lt;/phase&gt;        &lt;goals&gt;          &lt;goal&gt;run&lt;/goal&gt;        &lt;/goals&gt;      &lt;/execution&gt;    &lt;/executions&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;"
    }, {
    "id": 35,
    "url": "http://localhost:4000/Maven%E7%9A%84IDE%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
    "title": "Maven的IDE集成使用与生命周期",
    "body": "2017/01/19 - 在实际开发中，我们不是使用命令行或者记事本，而是使用诸如IDEA或者Eclipse的IDE进行开发，本文将介绍Maven与IDE集成和使用以及Maven的生命周期 在eclipse中安装maven插件以及创建maven项目: 由于IDEA默认集成Maven所以不做介绍  在eclipse4. 0及MyEclipse中就不需要安装maven插件，在window–preference中可以查看是否有maven插件，没有的话就需要安装Maven插件，直接复制Maven插件到eclipse安装目录中的dropins中，然后修改eclipse. ini,在这个文件里的512m后面添加-vm,换行，再添加jdk/bin/javaw. exe保存。 eclipse是默认运行在jre之上的而maven需要jdk的支持，需要tools. jar在jdk/lib目录中，所以修改eclipse的JRE，java—Installed JREs–ADD–Next–把本地JDK的目录放到JRE home中，并设置Dmaven. multiModuleProjectDirectory=$M2_HOME–最后勾选JDK 更改maven本地的配置Installactions—ADD—把本地的maven目录放进去 修改setting的路径集成时遇到的问题: 如果版本不匹配 则mvn -v查看maven的jdk版本，然后在eclipse中配置当前使用的jdk Eclipse中run as–&gt;Maven build…–&gt;在goals中compile（可以在此处使用其他的命令，如：package）—&gt;run若报-Dmaven. multiModuleProjectDirectory错误，则在选项–&gt;java–&gt;installed JRES 中设置jdk的参数，添加上“-Dmaven. multiModuleProjectDirectory=$M2_HOME” Maven的生命周期和插件: Maven的生命周期大概如下： clean compile test package install 这几个命令对应了一个项目的完整的构建过程，这几个步骤对应的都有插件来完成：清理、编译、测试、打包、集成测试、验证、部署 Maven的生命周期分为三个独立的生命周期（每一个生命周期有分为若干个阶段，其中defaul是最核心的一个）：  clean 清理项目 default 构建项目 site 生成项目的站点clean 清理项目：: pre-clean ：执行清理前的工作clean：清理上一次构建生成的所有文件post-clean：执行清理后的文件 default构建项目（最核心）: compile test package install site 生成项目站点: pre-site 在生成项目站点之前要完成的工作site 生成项目的站点文档post-site在生成项目站点后要完成的工作site-deploy发布生成的站点到服务器上 注意：Maven的生命周期对应的命令是顺序执行的，如果没有人为的顺序的一个个执行，那么Maven会默认的自动运行。 "
    }, {
    "id": 36,
    "url": "http://localhost:4000/Java%E6%B3%A8%E8%A7%A3/",
    "title": "Java注解",
    "body": "2017/01/11 - 学习注解最重要的就是弄清楚，为什么学习注解？学习注解的好处？学完能做什么？1、能够读懂别人写的代码，特别是框架相关的代码；2、能让编程更加简洁，代码更加清晰； 基本概念: 注解是Java提供的一种 源程序中的元素关联任何信息和任何元数据的途径和方法。 按来源分类注解:  java自带注解—— @Override 覆盖了父类的方法、@Deprecation 表示方法已经过时、@Suppvisewarnings 用于通知java编译器忽略特定的编译警告 第三方注解—— 种类很多，Spring的@Resource Hibernate 的@Entity等等 自定义注解—— 自定义注解的结构：元注解（用来注解注解的）、@接口定义、无参无异常的成员方法的定义（成员类型受限：基本数据类型、String、枚举）按照运行机制分类注解:  源码注解——注解只在源码中存在，编译程. class文件时就不存在了 编译时注解——注解在源码和. class文件都会存在的，JDK自带的注解都是编译时注解 运行时注解——在运行阶段还起作用，甚至会影响运行逻辑的注解，比如：@Autowired。学会自定义注解: 学习注解最终就是要把他应用的实际中，其中看懂注解固然重要，会自定义注解并在实际项目中解决问题也不可忽视 要自定义注解就要先了解下面的的元注解：  @Target—作用域（constructor(构造方法声明)，field（字段声明），local_variable（局部变量声明），method（方法声明），package（包声明），parameter（参数声明），type（类，接口声明）） @Retention—生命周期（source：只在源码显示，编译时会丢弃。class：编译时会记录到class中，运行时忽略。runtime：运行时存在，可以通过反射读取） Inherited—标识注解(允许子类继承) Documented—生成Javadoc下面看一个自定义注解的实例: 12345678910111213141516171819@Target({ElementType. METHOD,}) //作用域(控制注解能被用在什么地方)@Retention(RetentionPolicy. RUNTIME) //生命周期@Inherited //标识注解(允许子类继承)@Documented //生成javadoc会生成注解信息public @interface Description {  //1. 类型受限制，包括基本类型及String、Class、Annotation、Enumeration  //2. 若只有一个成员，则名称必须为value(),使用时可以忽略成员名和赋值号(=)  //3. 注解类可以没有成员，称为标识注解  //4成员无参且无异常声明  String desc();  String author();  //5可指定默认值  int age() default 18;}public @interface Description{  String desc;  String author;  int age default 18;}解析注解: 概念：通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。 只是定义注解而不解析是没有任何用处的，解析注解为注解学习的核心，最主要的是了解两个方法isAnnotationPresent和getAnnotation @Inherited（子类是否可继承） 对接口interface、方法继承没有作用，对类才有效。通过反射回去类，函数或成员以上的运行时的注解信息从而实现动态控制程序运行的逻辑 1234567891011121314151617181920212223242526272829303132//1. 使用类加载器加载类try {  Class c = Class. forName( com. ann. test. Child );  //2. 找到类上的注解  boolean isExist = c. isAnnotationPresent(Description. class);  if(isExist){    //3. 拿到注解实例    Description d = (Description)c. getAnnotation(Description. class);    System. out. println(d. value());  }  //4. 找到方法上的注解  Method[] ms = c. getMethods();  for(Method m:ms){    boolean isMExist = m. isAnnotationPresent(Description. class);    if(isMExist){      Description d = m. getAnnotation(Description. class);      System. out. println(d. value());    }  }  //另外一种解析方法  for(Method m:ms){    Annotation[] as = m. getAnnotations();    for(Annotation a:as){    if(a instanceof Description){      Description d = (Description)a;      System. out. println(d. value());    }    }  }} catch (ClassNotFoundException e) {  e. printStackTrace();}"
    }, {
    "id": 37,
    "url": "http://localhost:4000/%E5%88%9D%E8%AF%86Maven/",
    "title": "初识Maven",
    "body": "2017/01/04 - 试想一下，当我们要开展一个新项目的时候。我们第一步就是搭建环境。要从各大官网找jar包、下载jar包、然后分辨重复的、是否有用的、最后放到项目中，项目还没开始就要放几十个jar包，还可能在开发时因为少放了一个而出各种bug，这样做维护时间和成本都很高。Maven可以很好的帮助我们管理jar包，这也就是我们要学习并使用Maven的原因 什么是Maven: Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。 Maven是自动化构建工具，可以管理第三方的jar包。 Maven源文件的目录结构: 要使用Maven，首先要到官网下载MavenMaven官网下载地址下载完成后解压如下图  bin目录包含Maven的运行脚本 boot目录包含一个类加载器的框架，Maven使用它来加载自己的类库 conf是配置文件目录 lib是类库（自身及第三方）此时Maven已经安装到电脑中，打开CMD，进入bin目录输入mvn -v即可查看Maven版本。当然为了方便使用，最好把Maven配置到环境变量中，一般命名为M2_HOME（配置方法和JAVA_HOME一样） Maven项目的目录结构: 使用Maven构建项目时要遵守Maven的目录结构，如下： 12345678src   -main     -java        -package   -test     -java        -package   resourcesMaven常用命令: mvn compile: 编译主程序源代码，不会编译test目录的源代码。第一次运行时，会下载相关的依赖包，可能会比较费时， 生成target文件夹 mvn test: 运行应用程序中的单元测试会生成target文件夹，主程序编译的字节码文件在classes下面，测试程序放在test-classes下，surefire-reports文件夹下面存放是的所生成的测试报告 mvn package: 会在target目录下生成一个jar文件 mvn clean: 删除target文件夹 由于Maven创建项目的时候要遵守Maven的目录结构，那么每次创建项目的时候我们都手动建立合法目录结构是很麻烦的事，所以 Maven为我们提供的以下两种自动化方式快速创建项目 12345mvn archetype:generate 按照提示进行选择mvn archetype:generate -DgroupId= 组织名 ，公司网址的反写+项目名            -DartifactId=项目名-模块名            -Dversion=版本号            -Dpackage=代码所存在的包名坐标与仓库: 坐标: 构建 maven的唯一标识 groupid artifactId version 共同构建一个坐标仓库: 本地仓库和全球仓库M2_HOME\lib\maven-model-builder-版本号. jar中的pom-4. 0. 0. 0. xml中记录了默认的全球仓库的地址 由于国内被墙的缘故，直接从Apache 中央仓库下载jar包会很费时间，所以大多使用镜像仓库，访问速度快，也比较稳定 镜像仓库：修改镜像仓库的位置：M2_HOME\conf\setting. xml &lt;mirrors&gt; &lt;mirror&gt;  &lt;id&gt;maven. net. cn&lt;/id&gt;  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;!--可以用*匹配所有的镜像，一旦配置了镜像，所有针对原仓库进行的访问都会转到这个配置的镜像仓库，原仓库将不能再访问--&gt;  &lt;name&gt;central mirror in china&lt;/name&gt;  &lt;url&gt;http://maven. net. cn/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt;&lt;!--下面的配置是使用oschina的远程仓库：--&gt; &lt;mirror&gt;   &lt;id&gt;maven. oschina. net&lt;/id&gt;   &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;   &lt;name&gt;central mirror in oschina&lt;/name&gt;   &lt;url&gt;http://maven. oschina. net/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;修改仓库位置：默认存在位置：用户目录. m2\repository修改settings. xml中的localRespository节点的路径之后即修改了仓库的默认位置 "
    }, {
    "id": 38,
    "url": "http://localhost:4000/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%AF%87/",
    "title": "存储过程高级篇",
    "body": "2016/12/29 - 继续上文的初级篇，聊一聊存储过程的常用特性，谈谈存储过程在工作中的具体使用，希望能对读者有所帮助。 参数传入模式: PL/SQL存储过程有三种传参模式in 、out、in out。默认情况下（即不写）为in模式先来看看下面的存储过程： 12345678910--in 、out、 in out模式测试create or replace procedure proc_param_demo(p1 in number,p2 out number,p3 in out number) asbegin dbms_output. put_line('测试in  模式存储过程中p1的值为：'||p1);--标准输出 dbms_output. put_line('测试out  模式存储过程中p2的值为：'||p2); dbms_output. put_line('测试in out模式存储过程中p3的值为：'||p3); --p1 :=100; --报错 p2 := 100; --:=PL/SQL标准赋值 p3 :=100;end;调试完错误之后，调用上面的存储过程，这次调用我们不直接把值传递给存储过程的参数。所以需要使用declare关键字来声明变量，然后就可以在执行区域才可以使用这些变量： 12345678910111213declare --声明区域p1 number;p2 number;p3 number;begin p1 := 10; p2 := 10; p3 := 10; proc_param_demo(p1,p2,p3); dbms_output. put_line('测试in  模式存储过程后p1的值为：'||p1); dbms_output. put_line('测试out  模式存储过程后p2的值为：'||p2); dbms_output. put_line('测试in out模式存储过程后p3的值为：'||p3);end;输出结果如下图所示： 通过测试可以得到以下结果：  in模式可以理解为引用传递，它的值被完整的传入到存储过程中，但在执行过程中不能被重新赋值，我们传递的值执行之后不会发生改变。 out模式为值传递，它的值在传入到存储过程的时候会默认赋值为null，可以在执行的时候为其赋值，执行之后传递的值也会随之改变 in out模式为值传递，它的值被完整的传入到存储过程中，可以在执行的时候为其赋值，执行之后传递的值也会随之改变总结：可以把in模式看做是向存储过程传递的不想被改变的参数，可以把out模式看做返回值，当执行之后out模式的值就会随着业务逻辑发生改变以供我们使用，而in out模式则很灵活，我们即可以把它当参数传递，也可以当做返回值来使用。 控制语句: 流程控制语句语句无处不在，只要有一点编程基础就能够理解，在这里我列举一些在工作中常用的语法，详细语法请参考官方文档 IF判断语句123IF 条件 THEN 执行体;END IF;12345IF 条件 THEN 执行体;ELSE 执行体; END IF;1234567IF 条件 THEN 执行体;ELSEIF 条件 THEN 执行体; ELSE 执行体; END IF;CASE选择语句123456CASE 变量 WHEN 匹配变量 THEN  执行体;  WHEN 匹配变量 THEN  执行体;  WHEN 匹配变量 THEN  执行体;  ELSE 执行体; END CASE;LOOP循环语句1234567LOOP  执行体; IF 条件 THEN  执行体;  EXIT;--此处为跳出循环 END IF; END LOOP1234LOOP  执行体; EXIT WHEN 条件;--跳出循环 对比的有CONTINUE和CONTINUE WHEN语法END LOOP FOR i IN 1. . 3 LOOP -- FOR EACH 语法，遍历1~3并输出 --执行体;  DBMS_OUTPUT. PUT_LINE (TO_CHAR(i)); END LOOP;流程控制语句先了解其语法即可，因为它无处不在，我们就可以在实践中慢慢的掌握并精通。 Cursor游标:  An explicit cursor names the unnamed work area in which the database stores processing information when it executes a multiple-row query. When you have named the work area, you can access its information, and process the rows of the query individually. 翻译：Cursor就是当我们在数据库一块未命名的存储数据的工作空间进行多行查询的时候对其进行命名。当你对一块工作空间命名之后，你就可以获取并处理这些查询的数据总结：可以把Cursor理解为一个有名称的结果集，当需要的时候就可以拿过来用，也可以吧Cursor看成一个实体类，存储了我们定义的数据。 参考官方文档 接下来我们通过看一个具体的例子了解cursor的具体实现，需求为从emp中查出所有的姓名和其职位输出 12345678create or replace procedure proc_cursor_demo ascursor emp_cursor is    --定义cursorselect * from emp;     --将数据空间指向emp_cursorbegin for emp_data in emp_cursor loop      --遍历cursor数据输出  dbms_output. put_line(emp_data. ename ||' 的工作为: '||emp_data. job); end loop;end;结果如下 异常: 存储过程的异常在工作中非常常用，但具体使用一般很简单，包括自定义异常和系统异常，jojo52013145总结的很好，如果想深入了解请参考他的文章。 实践: 不管学习什么光说不练都是假把式，看到的知识不一定是自己的，只有实践之后才能真正的理解，让我们通过一个例子。比如说我们有这样的一个需求，要把emp表中有奖金的员工提取到另外一个表，并在员工的姓名后添加后缀_V。下面就是实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657create or replace procedure proc_copy_demo(tn in varchar2)asv_count number;       --检查是否已经有这个名称的表了tablename varchar2(20);   --表名称v_emp_copy emp%rowtype;   --表结构v_sql varchar(200);      --sqlcursor emp_data_cursor is  -- 将有emp表中有奖金的人员放到cursor中select * from emp where comm&gt;0; --过滤有奖金的begin tablename := tn; -- 定义表名称 select count(*) into v_count from user_objects where object_name = upper(tablename); -- 查询用户表，校验是否已经存在名称为tablename的表 if v_count&gt;0 then  -- 表存在  execute immediate 'drop table '|| tablename ||' cascade constraints'; -- 执行删除表 execute immediate执行SQL语句 end if; execute immediate 'create table '|| tablename ||' as select * from emp where 1=2'; -- 新建表结果和emp相同的表，添加条件后只创建表，不添加数据 for emp_data in emp_data_cursor loop     -- 从cursor中取出数据，做一些处理并插入到指定表中   v_emp_copy. empno := emp_data. empno;   v_emp_copy. ename := emp_data. ename || '_A';   v_emp_copy. job := emp_data. job;   v_emp_copy. mgr := emp_data. mgr;   v_emp_copy. hiredate := emp_data. hiredate;   v_emp_copy. sal := emp_data. sal;   v_emp_copy. comm := emp_data. comm;   v_emp_copy. deptno := emp_data. deptno;         v_sql := 'insert into '||tablename||' values    (' ||v_emp_copy. empno  ||','''     ||v_emp_copy. ename  ||''','''     ||v_emp_copy. job   ||''','     ||v_emp_copy. mgr   ||','''     ||v_emp_copy. hiredate ||''','     ||v_emp_copy. sal   ||','     ||v_emp_copy. comm   ||','     ||v_emp_copy. deptno  ||')';   dbms_output. put_line(v_sql);   execute immediate v_sql; end loop; commit; exception      -- 捕获异常常用写法  when others then     dbms_output. put_line('捕获的异常代码（SQLCODE） 为 ' ||SQLCODE );    -- 输出异常信息    dbms_output. put_line('捕获的异常信息（SQLERRM） 为 ' ||SQLERRM);end;-------------------------test-------------------------------begin proc_copy_demo('emp_copy'); end;-------------------------test-------------------------------运行之后可能会出现下面的输出，PL/SQL抛出了一个异常，通过异常捕获机制，我们可以轻松的找到问题所在。因为我们没有为scott用户赋予创建标的权限，具体代码如下： 12revoke create table from scott -- 收回scott创建表的权限 grant create table to scott  -- 赋予scott创建表的权限然后再执行上面的存储过程，我们会发现想要的数据已经被提取到emp_copy表中了。 "
    }, {
    "id": 39,
    "url": "http://localhost:4000/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%88%9D%E7%BA%A7%E7%AF%87/",
    "title": "存储过程初级篇",
    "body": "2016/12/24 - 本文旨在把自己学到的有关存储过程的知识和大家分享，并希望能够帮助正在被存储过程折磨的同学。 什么是存储过程:  官方定义：A procedure is a subprogram that performs a specific action  A PL/SQL subprogram is a named PL/SQL block that can be invoked repeatedly. If the subprogram has parameters, their values can differ for each invocation.  A subprogram is either a procedure or a function. Typically, you use a procedure to perform an action and a function to compute and return a value. 翻译：存储过程是一个可以执行特定行为的子程序 PL/SQL子程序是一个可以被重复调用的拥有名称的PL/SQL块（PL/SQL程序都是以块为基本单位的）。如果这个子程序有参数，我们则可以在调用的时候赋予不同的参数 子程序可以是存储过程或函数。通常情况下，你可以使用存储过程来执行一个动作，使用函数来计算并返回一个值 总结：存储过程对于不同的领域的人有不同的理解方式。可以把它理解为一个指令集，它可以帮助我们完成一系列复杂的数据操作，也可以把它看做一个专门处理SQL的批处理工具，在需要的时候执行一些增删改查的操作。 为什么学习存储过程: 相信在学习存储过程的你一定已经对普通SQL了如指掌了，简单了解了存储过程的概念之后，用普通的SQL与存储过程进行比较可以让我们在工作中做出正确的选择。两者区别很大，详细的对比可以问度娘，由于本文主讲存储过程，故罗列一些重要存储过程的优点如下：  降低网络的通讯量。如果只是执行简单的SQL语句的话存储过程和普通SQL没有太大差别，但随着时间的推移SQL量越来越大甚至达到上百行时，其优越性明显体现 提高执行效率。我们都知道SQL是先编译再执行的，而存储过程是预编译在服务器中的，当执行的时候跳过编译的环节效率自然会提高 可维护性高。更新存储过程通常比更新，测试，重新部署需要较少的时间和精力总之存储过程是一个SQL提供的一个非常优秀的功能，在工作中我们或多或少都会用到，学会存储过程绝对会让你受益匪浅。 PL/SQL存储过程: 基本语法存储过程在不同的数据库语言中语法略有不同，本文针对ORACLE的PL/SQL，但其他数据库语言也是大同小异 上图是一个存储过程的模型，由此可知一个最简单的存储过程必须包含以下关键字CREATE、PROCEDURE、存储过程名称、IS/AS、PL/SQLB标准执行语句（BEGIN … END;）。通过不断的实践我们将会完全理解上图的含义。首先从简单的存储过程开始(其功能是向EMP表中添加一条数据)： 12345678910111213create    -- 存储过程头部区域开始 or replace  --可选表示如果数据库中已经存在一条相同名称的存储过程就把它替换掉procedureproc_emp_create --存储过程名称 procedure_name(empno number, ename varchar2, job varchar2, mgr number, hiredate date, sal number, comm number, deptno number) -- parameter_declaration 声明参数（注意不需要写长度），存储过程头部区域结束as--声明区域，不需要声明变量可以不写begin -- PL/SQL标准执行语句--执行区域 insert into emp values(empno, ename, job, mgr, hiredate, sal, comm, deptno);end;当我们执行上面的存储过程之后这条存储过程就被编译到数据库中了，进入PLSQL Developer中的Procedures文件夹就可以看到我们刚才创建的存储过程了 既然存储过程已经写好并编译完成了，接下来就是使用我们创建的存储过程了。使用存储过程有两种方法：第一种是直接在SQL窗口中，执行SQL语句。 123begin proc_emp_create(7778,'Alexander','analyst',6789,sysdate,4321,'',20);end;第二种是在命令窗口中使用execute命令 Connected to Oracle Database 11g Enterprise Edition Release 11. 2. 0. 1. 0 Connected as scott SQL&gt; execute  proc_emp_create(7778,'Alexander','analyst',6789,sysdate,4321,'',20); PL/SQL procedure successfully completed SQL&gt; 无论使用哪一种方法，我们都会发现在EMP表中已经多了一条刚才插入的数据。也就是说，我们以后想要向EMP表中插入数据的话，就可以直接调用这条存储过程来执行插入操作。 从上面的例子可以看出，一个存储过程可以分成三个区域  头部区域 用于编写最基本的存储过程头部标记，定义是否要创建一个替代原有存储过程的存储过程；决定是否定义参数；定义参数的类型（in out inout）；定义执行权限（Schema）。 声明区域 用于声明变量（要定义长度）包括cursor； 执行区域用于执行业务逻辑代码，可以使用条件语句（选择、判断、循环。。。）来进行一些业务逻辑CRUD的处理继续实践了解了存储过程的基本语法和用途之后，再通过一些简单的实例可以帮助我们更好的理解存储过程的语法和其含义。上面的例子简单的完成了对EMP表的添加功能，接下来将会使用存储过程对EMP进行删除、修改和查询功能，实现完整的CRUDD创建用于根据EMPNO删除EMP中一条数据的存储过程 1234create or replace procedure proc_emp_delete(deleteid number) asbegin  delete from emp where empno = deleteid;end;执行（两种方法任选其一即可） 123begin proc_emp_delete(7778);end;执行完成之后，刚才我们在了解存储过程语法的那条数据就被删除了U接下来来写更新的存储过程，首先准备一条数据 123begin proc_emp_create(7778,'Alexander','analyst',6789,sysdate,4321,'',20);end;执行之后刚才被我们删掉的数据就又重新插入到EMP表中，接下来写更新的存储过程 123456789create or replace procedureproc_emp_update (p_empno number, p_ename varchar2, p_job varchar2, p_mgr number, p_hiredate date, p_sal number, p_comm number, p_deptno number) asbegin update emp set ename = p_ename,job = p_job,mgr = p_mgr,hiredate=p_hiredate,sal = p_sal,comm=p_comm,deptno = p_deptno where empno=p_empno;end;需要注意的是参数不能和字段表的名称相同，接下来执行 123begin proc_emp_update(7778,'Alexander','analyst','6789',sysdate,4321,3000,10);end;再次查询会发现Alexander的奖金多了3000块。R最后要做的就是查询了，对于多条数据的查询输出要使用cursor，留在下篇文章中讨论，我们先做一个最简单的单条数据查询 1234567create or replace procedure proc_emp_readas v_no number;--声明变量begin  select count(empno) into v_no from emp;--在执行代码块里面查询一定要使用into赋值 dbms_output. put_line(v_no);end;接下来执行 123begin proc_emp_read;end;我的结果如下图所示： 至此，简单的CRUD实践就完成了，相信你已经对存储过程有了大概的理解并能写出简单存储过程了。当然这只是存储过程最基本的使用方法，其高级特性（cursor、schema、控制语句、事务等）将在下篇文章中讨论。 "
    }, {
    "id": 40,
    "url": "http://localhost:4000/%E5%88%9D%E8%AF%86HTTP%E5%8D%8F%E8%AE%AE/",
    "title": "初识HTTP协议",
    "body": "2016/12/14 - HTTP无处不在，理解HTTP协议可以帮助我们更好的理解网络 浏览器请求流程概要: 思考：当用户输入一个链接或者按F5刷新的时候浏览器内部都做了什么?  Chrome搜索自身的DNS缓存（一般缓存的时间只有一分钟，可以通过chrome://net-internals/#dns查看Chrome浏览器缓存 搜索操作系统自身的DNS缓存（浏览器没有找到缓存或者缓存已经失效） 读取本地的HOST文件 浏览器发起一个DNS的系统调用(宽带运营商提供的) 浏览器获得域名对应的IP地址后，发起HTTP“三次握手” TCP/IP连接建立起来之后，浏览器就可以向服务器发送HTTP请求了，使用了比如说GET方法请求一个根域的域名，协议可以采用HTTP1. 0协议 服务器接受到了这个请求，根据路径参数，通过后端的一些处理之后，把处理后的一个结果数据返回给浏览器，如一个网站的代码 浏览器拿到完整的HTML代码，在解析和渲染这个页面的时候，里面的JS、CSS、图片静态资源，他们同样也是一个个HTTP请求都要经过上面主要七个步骤 浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面展现给用户运营商的做法:  宽带运营商服务器查看本身缓存 运营商服务器发起一个迭代的DNS解析请求     询问根域（. com . cn eg. ）   根据顶级域查找对应的IP（baidu. com nodejs. org eg. ）   根据上级域找域名注册商可以获取IP   运营商返回IP之后怎么做:  服务器运营商把结果返回操作系统内核同时缓存起来 操作系统内核把结果返回给浏览器 最终浏览器拿到了请求的IPHTTP请求:  HTTP头发送的是一些附加信息：内容类型、服务器发送响应的日期、HTTP状态码 HTTP正文用户提交的表单数据或者是返回的数据HTTP请求分析: Timing: 通过分析Timing找到页面加载瓶颈  stalled 等待时间，浏览器要发出请求，到请求可以发出的等待时间（TCP连接释放的时间登），不包含DNS查询和建立TCP连接的时间 Proxy negotiation 代理协商的时间 Request send 请求的第一个字节发出之前到最后一个字节发出后的时间，请求时间 请求发出之后到收到响应的第一个字节锁花费的时间 Content download 收到响应的第一个字节开始到收到最后一个字节所话费的时间Headers:  Remote Address 域名解析后的地址 Request URL 请求地址 Request method 请求方法 Status code 状态码请求方法:  GET 一般获取读取数据 POST 一般提交数据 PUT 更新数据 DELETE 删除 HEAD TRAGCE OPTIONS。。。状态码:  1XX 请求已经接受了，正在处理 2XX 请求已经接受并处理完成     200 请求成功    3XX 重定向 4XX 客户端请求错误     400 客户端请求语法错误   401 请求没有经过授权   403 服务器收到请求但是拒绝提供   404 找不到资源    5XX 服务器错误 500 服务器端发生不可预期的错误 503 服务器端当前还不能处理请求，可能过一段时间会恢复正产"
    }, {
    "id": 41,
    "url": "http://localhost:4000/Hybrid-App-%E5%85%B3%E9%97%AD%E9%A1%B5%E9%9D%A2%E5%92%8Clistview%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE/",
    "title": "Hybrid App 关闭页面和listview动态加载数据",
    "body": "2016/12/07 - AppCan 的页面是由两个HTML组成，如果要完全关闭的话需要在主HTML eg. index. html中关闭,关闭方法：appcan. window. close(-1); 管道:  AppCan中两个页面通过管道连接，并传递数据 appcan. window. publish(channelId,msg) 向指定通道发送消息 appcan. window. subscribe(channelId,callback) 订阅一个频道，如果有消息发给该频道，则会执行响应的回调如果是用超链接打开的页面收不到消息示例: 需要注意的是，要确保publish方法执行过即开通了一个管道才可以接收到信息 12345678910111213141516171819202122//在. . . _content页面发送消息function send() {  //发送消息  appcan. window. publish('test', 'hello');  alert( 发送成功 );}//在. . . html文件ready方法中打开管道appcan. ready(function() {  appcan. window. subscribe('test', function(msg) {  if (msg == 'hello') {    closeMyself();  } else {    alert( test );  }});//执行获取正确信息后的方法function closeMyself() {  alert( closeMyself调用 );  appcan. window. close(-1);}listview动态加载数据: appcan —&gt; 添加列表 —-&gt;带图片的列表 123456789101112131415161718192021//自动生成var lv = appcan. listview({  selector :  #listview ,  type :  thinLine ,  hasIcon : false,  hasAngle : true,  hasSubTitle : true,  multiLine : 1,});lv. set([{  title :  临时数据 ,  subTitle :  12:05 ,  id :  1 }, {  title :  临时数据 ,  subTitle :  12:05 ,  id :  2 }])lv. on( click , function(ele, obj, curEle) {})1234567891011//从服务器获取数据function getData() {  var url =  服务器地址  +  用户登录id ;  apcan. request. getJSON(url, function(data) {    //提前判断是否加载成功，现将data解析    showMenu(data) {    }  }, 'json', function(err) {    alert(err);  },  get ,   , false);}123456789101112131415161718//将信息动态赋值给listviewfunction showMenu(data) {  var lv = appcan. listview({    selector :  #listview ,    type :  thinLine ,    hasIcon : false,    hasAngle : true,    hasSubTitle : true,    multiLine : 1,  });  var datalist = data. data;  for(i=0;i&lt;data. datalist. length;i++){    datalist[i]. title = data. data[i]. title;    datalist[i]. describ = data. data[i]. content;    datalist[i]. subtit = data. data[i]. uid;    lv. set(datalist);  }}"
    }, {
    "id": 42,
    "url": "http://localhost:4000/Hybrid-App-Request%E5%92%8C%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/",
    "title": "Hybrid App Request和登录功能简单实现",
    "body": "2016/11/30 - 记录在apcan中对数据的请求获取 实现appcan中网络数据的上传和获取 常用参数: 12345678options. type:    请求的类型，包括GET、POST等options. url:     要请求的地址 注：get方式请求中携带中文参数，需要对参数进行encode编码，具体函数：encodeURIComponentoptions. data:    要请求的URL的参数,如果要上传文件则data数据中必须传一个对象包含一个path的key 例如：data:{file:{path:'a. jpeg'},file2:{path:'b. jpeg'}}上传        a. jpeg,b. jpeg图片options. dataType:  服务端的响应类型，包括json, jsonp, script, xml, html, text中的一种options. timeout:   请求的超时时间options. success(data, status,,requestCode,response, xhr):  请求发送成功后的回调options. error(xhr, errorType, error,msg):          请求如果出现错误后的回调;msg: 错误详细信息，服务器返回的result信息script代码: 12345678910111213141516171819202122232425appcan. button( #submit ,  ani-act , function() {      login();    })    function login() {      var name = $( #username ). val();      var pwd = $( #password ). val();      console. log(name +  :  + pwd);      appcan. ajax({        url :  http://testmas. appcan. cn:9000/ODBC/login?uName=  + name +  &amp;pwd=  + pwd,        type : 'get',        dateType : 'json',        success : function(data, status, xhr) {          var obj = eval('(' + data + ')');          alert(obj. status);          if(obj. status ==  0 ){            alert( 登录成功 );          }else{            alert( 用户名或密码不正确 );          }        },        error : function(xhr, status, errMessage) {          alert( errMessage );        }      });    }html代码: 1234567891011121314151617181920212223242526272829303132333435&lt;body class= um-vp bc-bg  ontouchstart&gt;    &lt;div class= ub ub-ver uinn-a3 ub-fv &gt;      &lt;div class= ub ub-ver uinn uinn-at1 &gt;        &lt;div class= umar-a uba bc-border c-wh &gt;          &lt;div class= ub ub-ac ubb umh5 bc-border  &gt;            &lt;div class=  uinput ub ub-f1 &gt;              &lt;div class= uinn fa fa-user sc-text &gt;&lt;/div&gt;              &lt;input id= username  placeholder= 手机/邮箱/用户名  type= text  class= ub-f1 &gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div class= ub ub-ac umh5 bc-border  &gt;            &lt;div class=  uinput ub ub-f1 &gt;              &lt;div class= uinn fa fa-lock sc-text &gt;&lt;/div&gt;              &lt;input id= password  placeholder= 密码  type= password  class= umw4 ub-f1 &gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;div class= ub ub-ver &gt;          &lt;div class= ub ub-pe uinn-a6 sc-text-active ulev-4 &gt;            忘记密码          &lt;/div&gt;          &lt;div class= uinn-at1 &gt;            &lt;div class= btn ub ub-ac bc-text-head ub-pc bc-btn uc-a1  id= submit &gt;              登录            &lt;/div&gt;          &lt;/div&gt;          &lt;div class= uinn-at2 ub sc-text-active ulev-4 &gt;          &lt;/div&gt;        &lt;/div&gt;        &lt;button type= submit class= uinvisible &gt;&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script src= js/appcan. js &gt;&lt;/script&gt;    &lt;script src= js/appcan. control. js &gt;&lt;/script&gt;  &lt;/body&gt;"
    }, {
    "id": 43,
    "url": "http://localhost:4000/Hybrid-App-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8F%8AListView%E7%9A%84%E5%BA%94%E7%94%A8/",
    "title": "Hybrid App 数据存储及ListView的应用",
    "body": "2016/11/24 - AppCan是Hybrid App开发框架即混合开发框架,由官方提供底层功能使用API HTML5和JavaScript只是作为一种解析语言，真正调用的都是Native App一样封装的底层功能 AppCan打包:    本地打包IDE生成的ipa包是越狱包，只能在越狱机安装，并且不支持app上传到应用市场     云端打包只需要按照AppCan的开发流程和规范开发，应用开发完后可直接将其上传到AppCan打包服务器，进行打包，平台会自动生成iOS/Android平台安装包，同事支持上传AppStore  HTML5:  LocalStorageLocalStorage 是window的全局属性，包括localStorage和sessionStorage,二者用法基本相同，但sessionStorage是会话级别的，窗口一旦被关闭就没了，而localStorage则一直存储在本地  12345在AppCan中的使用appcan. locStorage. getVal(key)        获取key保存在localStorage中对应的值appcan. locStorage. setVal(key，Val)     要设置的键值对appcan. locStorage. remove(key)        清除localStorage中对应的值appcan. locStorage. keys()          获取localStorage中，保存的所有键值   AppCan中ListView的使用: 列表组件是根据AppCan 布局框架对数据列表进行封装的JS对象，通过配合的样式，使开发者在界面中可以快速完成列表控件的开发。 使用之前要添加依赖: 12345appcan. jsappcan. control. jsappcan. listview. jsappcan. control. css使用方法:  常用参数  12345678910111213selector:                    /*选择器*/type:  thinLine or thickLine          /*窄行和宽行设定*/hasIcon:  true or false             /*是否有图片*/hasAngle:  true or false            /*是否有右侧箭头*/hasSubTitle:  true or false           /*是否有子标题*/hasTouchEffect:  true or false         /*是否有点击效果*/hasCheckbox:  true or false           /*是否有复选按钮*/hasRadiobox:  true or false           /*是否有单选按钮*/align:   left  or  right             /*checkbox和radiobox居左还是居右*/multiLine: 1 2 or 3               /*主标题文字占用最大行数。到达行数显示不全使用…替换*/touchClass: 'sc-bg-active' or 用户自定义     /*列表条目点击效果CSS类*/hasControl:  true or false           /*列表条目中是否包含switch组件。*/hasGroup:  true or false            /*列表条目是否以分组的形式展示。*/   示例: 定义HTML: 1234567891011121314151617181920212223&lt;!--定义一个listview的容器--&gt;&lt;style&gt;  . ubt {    border-top: 1px solid;  }  . ubb {    border-bottom: 1px solid;  }  . bc-border {    border-color: #BABABA;  }  . c-wh{    background-color: white;  }  . umar-at1{    margin-top:0. 625em;  }  . uinn-a7{    padding:0 0. 625em;  }&lt;/style&gt;&lt;div id= listview  class= ubt bc-border ubb c-wh umar-at1 uinn-a7 &gt;&lt;/div&gt;第一种script写法: 12345678910111213141516171819202122232425262728 var lv = appcan. listview({      selector :  #listview , //选择器，指定body标签中id为listview的容器      type :  thinLine ,   //窄行      hasIcon : true,     //指定是否有图标      hasAngle : true,    //指定是否有向右侧的箭头      hasSubTitle : true,   //指定是否有子标题      multiLine : 1      //指定主标题文字占的最大行数    });    lv. set([{      icon : 'personal_content/css/myImg/myImg1. png',     //指定图标      title : '我的相册',                   //指定标题文字      subTitle : '备注文字'                  //指定子标题文字    }, {      icon : 'personal_content/css/myImg/myImg2. png',      title : '我的收藏',      subTitle : ''    }, {      icon : 'personal_content/css/myImg/myImg3. png',      title : '我的银行卡',      subTitle : ''    }]);lv. on( click ,function(obj,data,subObj){    console. log(obj);                      //列表条目DOM对象    console. log(data);                      //列表条目对应数据源对象    console. log(subObj);                     //列表条目点击时的子元素DOM对象例如图片    appcan. window. open(data. pagename,data. pageurl,10);      //通过此方法打开对应的界面  })第二种script写法: 12345678910111213141516171819202122232425262728293031323334var arrData = [{      'tupian' : 'myWorkDOTO_content/css/myImg/myImg1. png',      'biaoti' : '我的相册',      'zibiaoti' : '备注文字',    }, {      'tupian' : 'myWorkDOTO_content/css/myImg/myImg2. png',      'biaoti' : '我的收藏',      'zibiaoti' : '',    }, {      'tupian' : 'myWorkDOTO_content/css/myImg/myImg3. png',      'biaoti' : '我的银行卡',      'zibiaoti' : '',    }];    var listData = [];    for (var i = 0,      len = arrData. length; i &lt; len; i++) {      var list = {        title : arrData[i]. biaoti,        icon : arrData[i]. tupian,        subTitle : arrData[i]. zibiaoti      }      listData. push(list);    }    var lv = appcan. listview({      selector :  #listview ,      type :  thinLine ,      hasIcon : true,      hasAngle : true,      hasSubTitle : true,      multiLine : 1    });    lv. set(listData);    lv. on('click', function(ele, context, obj, subobj) {    })"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});